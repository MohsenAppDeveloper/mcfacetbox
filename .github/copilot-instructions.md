# AI Coding Agent Instructions

These instructions summarize project-specific architecture, workflows, and conventions for the Vue 3 + Vite frontend in this repo.

## Core Architecture & Boot
- Entry: `src/main.ts` creates app, registers global directive `no-context-menu`, installs Toast + ContextMenu, then calls `registerPlugins(app)` (plugins live under `src/plugins`). Maintain this order when adding plugins.
- Global styles & fonts loaded before mount (`@/assets/fonts`, `@core/scss/template`, `@styles/styles.scss`). Add new global SCSS through `src/assets/styles` and keep imports centralized in `main.ts`.
- Core runtime setup in `@core/initCore.ts`: watchers sync RTL (`_syncAppRtl`), theme skin overrides (`_handleSkinChanges`), and initial loader colors (`_syncInitialLoaderTheme`). When adding theme features, extend these internal helpers instead of duplicating logic.

## Routing & Layouts
- Routes are auto-generated by `unplugin-vue-router` (see `vite.config.ts`). Route names are derived by converting PascalCase to kebab-case. When creating new page components under `src/pages/`, name them clearly; manual naming rarely needed.
- Layouts via `vite-plugin-vue-layouts` (`src/layouts/`). To add a layout: create a `.vue` file in `src/layouts/` and reference using the route meta if required.

## Auto Imports & Aliases
- `vite.config.ts` sets aliases: `@`, `@core`, `@layouts`, `@themeConfig`, `@store`, etc. Prefer these over relative paths.
- Auto-imported composables/functions from: `src/@core/utils`, `src/@core/composable`, `src/composables`, `src/utils`, `src/plugins/*/composables/*`. Avoid manual imports for these; update the AutoImport config if adding new utility folders.
- `ignore: ['useCookies','useStorage']` prevents accidental use of those auto imports; import them manually if needed.

## State Management (Pinia)
- Pattern: Composition-style `defineStore` returning primitives & functions (e.g., `treeStoreV3.ts`). Complex data stored in reactive containers (`shallowReactive Map`, `Set`) for performance.
- Immutable update approach: use helper `updateNode` to replace objects with `markRaw({...existing,...updates})`. Do not mutate node objects directly; always trigger replacement to keep shallow reactivity.
- Display vs storage: storage nodes are `markRaw`; display nodes built via `reactive` for components (`buildDisplayNode`). Preserve this separation when extending tree features.
- Maintain parent/child invariants: after create/move/delete, update parent `hasChildren` using `hasChildren()` or helpers like `setNodeChildrenState`.

## Theme & Internationalization
- Theme skin changes dynamically override Vuetify theme colors in `_handleSkinChanges`. Add new skins by defining `skin-{name}-background`/`surface` color tokens.
- RTL/language: language persisted via `cookieRef` & `useI18n`. To add a language, extend `themeConfig.ts` `app.i18n.langConfig` and provide locale files in `src/plugins/i18n/locales/**`.

## Icons & Assets
- Icon generation script: `pnpm build:icons` runs `src/plugins/iconify/build-icons.ts` via `tsx`. After adding new icon sets under `src/plugins/iconify`, rerun the script.
- SVG handled by `vite-svg-loader`; place shared SVGs under `public/images/svg` or `src/assets/images/svg` depending on runtime needs.

## Scripts & Tooling
- Use `pnpm` (see `packageManager` in `package.json`). Prefer `pnpm install` over npm; README is generic.
- Common commands: `pnpm dev` (serve), `pnpm build` (production), `pnpm preview --port 5050`, `pnpm typecheck`, `pnpm lint` (includes custom rules via `eslint-internal-rules/`). Run `pnpm postinstall` automatically (icons + MSW worker init).
- Mock service worker initialized in `public/` via `msw:init`; ensure worker regeneration after modifying handlers.

## Performance & Large Data Patterns
- Virtual tree rendering (`treeStoreV3.ts`) uses `flatVisibleNodes` computed with expansion state sets (`expandedNodes`, `loadedNodes`). When adding virtualized lists, emulate this separation of structural vs UI state.
- Chunk size warning raised to 5000 (`vite.config.ts`); large feature modules should still strive for code-splitting via dynamic imports in route components.

## Extending Functionality Safely
- Add plugins centrally within `registerPlugins(app)` to keep bootstrap consistent.
- When introducing a new store: follow composition pattern, avoid large object mutationâ€”use dedicated update helpers.
- For new auto-imported utilities, modify AutoImport `dirs` list rather than scattering manual imports.

## Contribution Pointers
- Keep architectural logic (theme, i18n, loader) consolidated in `@core/initCore.ts`.
- Use aliases for all cross-folder references to maintain clarity and refactor safety.
- Validate tree operations with parent `hasChildren` and invariant checks (`isDescendant`) before merging/moving.

## Quick Start
```sh
pnpm install
pnpm dev
# Optional diagnostics
pnpm typecheck
pnpm lint
```

Feedback welcome: indicate any unclear areas (e.g., plugin registration details, store patterns) to refine these instructions.
